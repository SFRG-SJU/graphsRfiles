vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
library(igraph)
#first the grid
k<-5
n<-7
gr<- make_lattice( c(k,n+1) )
#layout_on_grid(db)
tkplot(gr, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
cy<-add_edges(gr,ne)
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
library(igraph)
g1 <- sample_gnm(10, 20)
tkplot(g1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
A1<-as_adjacency_matrix(g1)
#ev<-eigen(A1)
#ev$values
A1
tg1<-minimum.spanning.tree(g1)
tkplot(tg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tA1<-as_adjacency_matrix(tg1)
tA1
E(tg1)
rtA1<-delete.edges(tg1,1-7)
rtA1<-delete.edges(tg1,1--7)
rtg1<-delete.edges(tg1,1--7)
tkplot(rtg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
sdList<-E(tg1)
edList<-E(tg1)
rtg1<-delete.edges(tg1,edList[2])
tkplot(rtg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
edList[2]
ed<-edList[2]
type(ed)
class(ed)
ed[1]
ed[1][1]
ed[1][1]
ed[[1]][1]
ends(ed)
adjacent_vertices(ed)
ends(tg1,ed)
tgA1<-as_adjacency_matrix(tg1)
tgA1
rtgA1<-as_adjacency_matrix(tg1)
rtgA1
rtgA1<-as_adjacency_matrix(rtg1)
rtgA1
subcomponent(rtg1, 1, "in")
subcomponent(rtg1, 1, "out")
subcomponent(rtg1, 1, "all")
subcomponent(rtg1, 7, "all")
subcomponent(rtg1, 1)
ends(tg1,ed)[1]
ends(tg1,ed)[2]
for(i in 1:7){ls}
ls<-c()
for(i in 1:7){ls<-c(ls,[i,i^2]), return(ls)}
for(i in 1:7){ls<-c(ls,c([i,i^2])), return(ls)}
max(length(subcomponent(rtg,ao[1]),
length(subcomponent(rtg,ao[2]))))}
edg.deg(tg1,E(tg1)[1])
max(4,6)
#first, function for degree of one edge
edg.deg<-function(tg,ed){ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
return(max(length(subcomponent(rtg,ao[1]),
length(subcomponent(rtg,ao[2])))))}
edg.deg(tg1,E(tg1)[1])
return(max(length(subcomponent(rtg,ao[1])),
length(subcomponent(rtg,ao[2]))))}
edg.deg(tg1,E(tg1)[1])
return(ans)}
result<-max(lapply(length(subcomponent(rtg, )),ao))
#first, function for degree of one edge
edg.deg<-function(tg,ed){ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
max(length(subcomponent(rtg,ao)))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-length(subcomponent(rtg,ao))
max(tc)}
edg.deg(tg1,E(tg1)[1])
print(tc)
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-length(subcomponent(rtg,ao))
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-subcomponent(rtg,ao)
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#small function for
mysc<-function(var1,var2){length(subcomponent(var1,var2))}
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
max(tc)}
edg.deg(tg1,E(tg1)[1])
edgs.degs<-function(var){sapply(E(var),edg.deg,tg=var)}
edgs.degs(tg1)
EDs<-rbind(E(tg1),edgs.degs(tg1))
EDs
EDs<-edgs.degs(tg1)
EDs
E(tg1)
#install.packages("igraph")
rm(list=ls())
library(igraph)
g1 <- sample_gnm(10, 20)
tkplot(g1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
A1<-as_adjacency_matrix(g1)
#ev<-eigen(A1)
#ev$values
A1
tg1<-minimum.spanning.tree(g1)
tkplot(tg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tgA1<-as_adjacency_matrix(tg1)
tgA1
#small function for size of component
mysc<-function(var1,var2){length(subcomponent(var1,var2))}
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
max(tc)}
#second, function of degrees of all edges
edgs.degs<-function(var){sapply(E(var),edg.deg,tg=var)}
EDs<-edgs.degs(tg1)
E(tg1)
EDs
library(igraph)
#first, given a graph, a spanning tree and an edge of of the
#spanning tree, calculate the congestion of the edge
edg.congestion<-function(g,tg,ed){
rtg<-delete.edges(tg,ed)
ved<-ends(tg,ed)
scp<-subcomponent(rtg,ved[1])
cong=0
for(eg in E(g)){
if(length(intersect(ends(g,eg),scp))==1){
cong<-cong+1}}
return(cong)}
#---------------------------------------
#second, given a graph and a spanning tree write a list with congestion
#of all edges of the tree
tree.congestion<-function(g,tg){
sapply(E(tg),edg.congestion,g=g,tg=tg)}
#first the grid
k<-3
n<-5
gr<- make_lattice( c(k,n+1) )
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db,tdb)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
Adb<-as_adjacency_matrix(db)
warning()
warnings()
Adb<-as_adjacency_matrix(db)
ev<-eigen(Adb)
vectors<-ev$vectors
vectors
tkplot(db, layout = vectors[15,16], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(15,16)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(14,16)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(13,16)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(13,14)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(13,15)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(11,12)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(11,13)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
cir<-array(for(i in 1:k){cos(2*Pi*i/k),sin(2*Pi*i/k)},c(2,k))
cir<-array(for(i in 1:k){c(cos(2*Pi*i/k), sin(2*Pi*i/k))},c(2,k))
cir<-array(for(i in 1:k){c(cos(2*pi*i/k), sin(2*pi*i/k))},c(2,k))
vcir<-c()
vcir<-for(i in 1:k){c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
vcir
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
vcir
cir<-c()
for(i in 1:n){cir<-c(cir,i*vcir)}
cir
pLcir<-array(cir,c(k*n,2))
Lcir<-rbind(c(0,0),pLcir)
Lcir
tkplot(db, layout = Lcir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
cir<-c()
for(i in 1:n){cir<-c(cir,i*vcir)}
cir
pLcir<-array(cir,c(k*n,2))
Lcir<-rbind(c(0,0),pLcir)
Lcir
cir<-array(cir,c(k,2))
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
vcir<-array(vcir,c(k,2))
vcir
cir<-c()
for(i in 1:n){cir<-rbind(cir,i*vcir)}
cir
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*(i-1)/k), sin(2*pi*(i-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir<-c()
for(j in 1:k){vcir<-c(vcir,cos(2*pi*(j-1)/k), sin(2*pi*(j-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#first the grid
k<-7
n<-5
gr<- make_lattice( c(k,n+1) )
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
vcir<-c()
for(j in 1:k){vcir<-c(vcir,cos(2*pi*(j-1)/k), sin(2*pi*(j-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir
for(j in 1:k){print(cos(2*pi*(j-1)/k))}
for(j in 1:k){print(sin(2*pi*(j-1)/k))}
0.6234898^2+0.7818315^2
sin(12*pi/7)
tkplot(db, tk_set_coords = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
rglplot(db)
rglplot(db, tk_set_coords=cir)
rglplot(db, tk_set_coords=cir)
for(i in 1:n){cir<-rbind(cir,i^2*vcir)}
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i^2*vcir)}
tkplot(db, tk_set_coords = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
rglplot(db, tk_set_coords=cir)
