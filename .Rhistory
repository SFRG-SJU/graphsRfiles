edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
max(length(subcomponent(rtg,ao)))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-length(subcomponent(rtg,ao))
max(tc)}
edg.deg(tg1,E(tg1)[1])
print(tc)
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-length(subcomponent(rtg,ao))
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-subcomponent(rtg,ao)
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#small function for
mysc<-function(var1,var2){length(subcomponent(var1,var2))}
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
max(tc)}
edg.deg(tg1,E(tg1)[1])
edgs.degs<-function(var){sapply(E(var),edg.deg,tg=var)}
edgs.degs(tg1)
EDs<-rbind(E(tg1),edgs.degs(tg1))
EDs
EDs<-edgs.degs(tg1)
EDs
E(tg1)
#install.packages("igraph")
rm(list=ls())
library(igraph)
g1 <- sample_gnm(10, 20)
tkplot(g1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
A1<-as_adjacency_matrix(g1)
#ev<-eigen(A1)
#ev$values
A1
tg1<-minimum.spanning.tree(g1)
tkplot(tg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tgA1<-as_adjacency_matrix(tg1)
tgA1
#small function for size of component
mysc<-function(var1,var2){length(subcomponent(var1,var2))}
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
max(tc)}
#second, function of degrees of all edges
edgs.degs<-function(var){sapply(E(var),edg.deg,tg=var)}
EDs<-edgs.degs(tg1)
E(tg1)
EDs
library(igraph)
#first, given a graph, a spanning tree and an edge of of the
#spanning tree, calculate the congestion of the edge
edg.congestion<-function(g,tg,ed){
rtg<-delete.edges(tg,ed)
ved<-ends(tg,ed)
scp<-subcomponent(rtg,ved[1])
cong=0
for(eg in E(g)){
if(length(intersect(ends(g,eg),scp))==1){
cong<-cong+1}}
return(cong)}
#---------------------------------------
#second, given a graph and a spanning tree write a list with congestion
#of all edges of the tree
tree.congestion<-function(g,tg){
sapply(E(tg),edg.congestion,g=g,tg=tg)}
#first the grid
k<-3
n<-5
gr<- make_lattice( c(k,n+1) )
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db,tdb)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
Adb<-as_adjacency_matrix(db)
warning()
warnings()
Adb<-as_adjacency_matrix(db)
ev<-eigen(Adb)
vectors<-ev$vectors
vectors
tkplot(db, layout = vectors[15,16], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(15,16)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(14,16)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(13,16)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(13,14)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(13,15)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(11,12)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db, layout = vectors[,c(11,13)], vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
cir<-array(for(i in 1:k){cos(2*Pi*i/k),sin(2*Pi*i/k)},c(2,k))
cir<-array(for(i in 1:k){c(cos(2*Pi*i/k), sin(2*Pi*i/k))},c(2,k))
cir<-array(for(i in 1:k){c(cos(2*pi*i/k), sin(2*pi*i/k))},c(2,k))
vcir<-c()
vcir<-for(i in 1:k){c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
vcir
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
vcir
cir<-c()
for(i in 1:n){cir<-c(cir,i*vcir)}
cir
pLcir<-array(cir,c(k*n,2))
Lcir<-rbind(c(0,0),pLcir)
Lcir
tkplot(db, layout = Lcir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
cir<-c()
for(i in 1:n){cir<-c(cir,i*vcir)}
cir
pLcir<-array(cir,c(k*n,2))
Lcir<-rbind(c(0,0),pLcir)
Lcir
cir<-array(cir,c(k,2))
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*i/k), sin(2*pi*i/k))}
vcir<-array(vcir,c(k,2))
vcir
cir<-c()
for(i in 1:n){cir<-rbind(cir,i*vcir)}
cir
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir<-c()
for(i in 1:k){vcir<-c(vcir,cos(2*pi*(i-1)/k), sin(2*pi*(i-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir<-c()
for(j in 1:k){vcir<-c(vcir,cos(2*pi*(j-1)/k), sin(2*pi*(j-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#first the grid
k<-7
n<-5
gr<- make_lattice( c(k,n+1) )
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
vcir<-c()
for(j in 1:k){vcir<-c(vcir,cos(2*pi*(j-1)/k), sin(2*pi*(j-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i*vcir)}
tkplot(db, layout = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
vcir
for(j in 1:k){print(cos(2*pi*(j-1)/k))}
for(j in 1:k){print(sin(2*pi*(j-1)/k))}
0.6234898^2+0.7818315^2
sin(12*pi/7)
tkplot(db, tk_set_coords = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
rglplot(db)
rglplot(db, tk_set_coords=cir)
rglplot(db, tk_set_coords=cir)
for(i in 1:n){cir<-rbind(cir,i^2*vcir)}
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i^2*vcir)}
tkplot(db, tk_set_coords = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
rglplot(db, tk_set_coords=cir)
library(igraph)
g1 <- sample_gnm(10, 20)
tkplot(g1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
A1<-as_adjacency_matrix(g1)
A1
tg1<-minimum.spanning.tree(g1)
tkplot(tg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tgA1<-as_adjacency_matrix(tg1)
tgA1
#first, given a graph, a spanning tree and an edge of of the
#spanning tree, calculate the congestion of the edge
edg.congestion<-function(g,tg,ed){
rtg<-delete.edges(tg,ed)
ved<-ends(tg,ed)
scp<-subcomponent(rtg,ved[1])
cong=0
for(eg in E(g)){
if(length(intersect(ends(g,eg),scp))==1){
cong<-cong+1}}
return(cong)}
E(tg1)
edg.congestion(g1,tg1,E(tg1)[1])
#---------------------------------------
#second, given a graph and a spanning tree write a list with congestion
#of all edges of the tree
tree.congestion<-function(g,tg){
sapply(E(tg),edg.congestion,g=g,tg=tg)}
tree.congestion(g1,tg1)
#####------------------------------------------
# Rectangular Grid
k<-5
n<-6
g2<- make_lattice( c(k,n) )
#layout_on_grid(db)
tkplot(g2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tg2<-minimum.spanning.tree(g2)
tkplot(tg2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
cong<-tree.congestion(g2,tg2)
cong
#---
g3 <- permute(g2, sample(vcount(g2)))
tg3<-minimum.spanning.tree(g3)
tkplot(tg3, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
cong<-tree.congestion(g3,tg3)
cong
max(cong)
#first the grid
k<-7
n<-5
gr<- make_lattice( c(k,n+1) )
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
vcir<-c()
for(j in 1:k){vcir<-c(vcir,cos(2*pi*(j-1)/k), sin(2*pi*(j-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i^2*vcir)}
tkplot(db, tk_set_coords = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db,tdb)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
max(cong)
#first the grid
k<-3
n<-5
gr<- make_lattice( c(k,n+1) )
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
vcir<-c()
for(j in 1:k){vcir<-c(vcir,cos(2*pi*(j-1)/k), sin(2*pi*(j-1)/k))}
vcir<-array(vcir,c(k,2))
cir<-c(0,0)
for(i in 1:n){cir<-rbind(cir,i^2*vcir)}
tkplot(db, tk_set_coords = cir, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
rglplot(db, tk_set_coords=cir)
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db,tdb)
cong
max(cong)
#----
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#----
cong<-tree.congestion(db2,tdb2)
cong
max(cong)
#---
