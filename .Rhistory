library(igraph)
g2<-make_graph(c(1,6,1,2,1,5,1,4,2,3,2,4,2,9,3,8,3,9,4,7,4,8,5,6,5,9,6,7,7,8), directed = FALSE)
l<-matrix(c(3,7.5,7.5,7.25,2,7,6.5,6,0,2.5,6,4.5,8,3,0.5,1,7,0),9,2, byrow = TRUE)
plot.igraph(g2,  layout = l)
#adjacency matrix of g2
A = matrix(c(0,1,0,1,1,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,0,0,0), 9, 9, byrow = TRUE)
A
ev<-eigen(A)
vectors<-ev$vectors
vectors
v2<-vectors[,2]
v3<-vectors[,3]
j<-cbind(v2,v3)
j
plot.igraph(g2, layout = j)
g1<-make_graph(c(1, 2, 2, 3, 3, 4, 5, 6), directed = FALSE)
#install.packages("igraph")
library(igraph)
g1<-make_graph(c(1, 2, 2, 3, 3, 4, 5, 6), directed = FALSE)
plot(g1)
#install.packages("igraph")
install.packages("rgl")
#first the grid
k<-15
n<-7
gr<- make_lattice( c(k,n) )
#layout_on_grid(db)
tkplot(gr, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#cylinder
ne<-c()
for(i in 1:n){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
library(igraph)
#first the grid
k<-15
n<-7
gr<- make_lattice( c(k,n) )
#layout_on_grid(db)
tkplot(gr, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#cylinder
ne<-c()
for(i in 1:n){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
library(igraph)
#first the grid
k<-5
n<-7
gr<- make_lattice( c(k,n+1) )
#layout_on_grid(db)
tkplot(gr, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
cy<-add_edges(gr,ne)
#cylinder
ne<-c()
for(i in 1:(n+1)){ne<-c(ne,(i-1)*k+1,i*k)}
cy<-add_edges(gr,ne)
tkplot(cy, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#dartboard
cl<-function(v){if(v<= k) {1} else {v}}
vl<-lapply(1:length(V(gr)),cl)
dbtemp<- simplify(contract.vertices(cy, vl), remove.loops=TRUE)
db<-delete_vertices(dbtemp,c(2:k))
tkplot(db, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb<-minimum.spanning.tree(db)
tkplot(tdb, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
#randomize labels on the nodes
#run it until you get something satisfactory
db2 <- permute(db, sample(vcount(db)))
tkplot(db2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tdb2<-minimum.spanning.tree(db2)
tkplot(tdb2, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
library(igraph)
g1 <- sample_gnm(10, 20)
tkplot(g1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
A1<-as_adjacency_matrix(g1)
#ev<-eigen(A1)
#ev$values
A1
tg1<-minimum.spanning.tree(g1)
tkplot(tg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tA1<-as_adjacency_matrix(tg1)
tA1
E(tg1)
rtA1<-delete.edges(tg1,1-7)
rtA1<-delete.edges(tg1,1--7)
rtg1<-delete.edges(tg1,1--7)
tkplot(rtg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
sdList<-E(tg1)
edList<-E(tg1)
rtg1<-delete.edges(tg1,edList[2])
tkplot(rtg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
edList[2]
ed<-edList[2]
type(ed)
class(ed)
ed[1]
ed[1][1]
ed[1][1]
ed[[1]][1]
ends(ed)
adjacent_vertices(ed)
ends(tg1,ed)
tgA1<-as_adjacency_matrix(tg1)
tgA1
rtgA1<-as_adjacency_matrix(tg1)
rtgA1
rtgA1<-as_adjacency_matrix(rtg1)
rtgA1
subcomponent(rtg1, 1, "in")
subcomponent(rtg1, 1, "out")
subcomponent(rtg1, 1, "all")
subcomponent(rtg1, 7, "all")
subcomponent(rtg1, 1)
ends(tg1,ed)[1]
ends(tg1,ed)[2]
for(i in 1:7){ls}
ls<-c()
for(i in 1:7){ls<-c(ls,[i,i^2]), return(ls)}
for(i in 1:7){ls<-c(ls,c([i,i^2])), return(ls)}
max(length(subcomponent(rtg,ao[1]),
length(subcomponent(rtg,ao[2]))))}
edg.deg(tg1,E(tg1)[1])
max(4,6)
#first, function for degree of one edge
edg.deg<-function(tg,ed){ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
return(max(length(subcomponent(rtg,ao[1]),
length(subcomponent(rtg,ao[2])))))}
edg.deg(tg1,E(tg1)[1])
return(max(length(subcomponent(rtg,ao[1])),
length(subcomponent(rtg,ao[2]))))}
edg.deg(tg1,E(tg1)[1])
return(ans)}
result<-max(lapply(length(subcomponent(rtg, )),ao))
#first, function for degree of one edge
edg.deg<-function(tg,ed){ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
max(lapply(length(subcomponent(rtg, )),ao))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
max(length(subcomponent(rtg,ao)))}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-length(subcomponent(rtg,ao))
max(tc)}
edg.deg(tg1,E(tg1)[1])
print(tc)
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-length(subcomponent(rtg,ao))
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-subcomponent(rtg,ao)
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#small function for
mysc<-function(var1,var2){length(subcomponent(var1,var2))}
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
print(ao)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
print(tc)
max(tc)}
edg.deg(tg1,E(tg1)[1])
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
max(tc)}
edg.deg(tg1,E(tg1)[1])
edgs.degs<-function(var){sapply(E(var),edg.deg,tg=var)}
edgs.degs(tg1)
EDs<-rbind(E(tg1),edgs.degs(tg1))
EDs
EDs<-edgs.degs(tg1)
EDs
E(tg1)
#install.packages("igraph")
rm(list=ls())
library(igraph)
g1 <- sample_gnm(10, 20)
tkplot(g1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
A1<-as_adjacency_matrix(g1)
#ev<-eigen(A1)
#ev$values
A1
tg1<-minimum.spanning.tree(g1)
tkplot(tg1, vertex.shape='circle',
vertex.size=15,
vertex.color='gold')
tgA1<-as_adjacency_matrix(tg1)
tgA1
#small function for size of component
mysc<-function(var1,var2){length(subcomponent(var1,var2))}
#first, function for degree of one edge
edg.deg<-function(tg,ed){
ao<-ends(tg,ed)
rtg<-delete.edges(tg,ed)
tc<-sapply(ao,mysc,var1=rtg)
max(tc)}
#second, function of degrees of all edges
edgs.degs<-function(var){sapply(E(var),edg.deg,tg=var)}
EDs<-edgs.degs(tg1)
E(tg1)
EDs
